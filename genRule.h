/* ///////////////////////////////////////////////////////////////////////////

  ====================
  Generate Rule Module
  ====================

  Module for generating code to apply a rule. The functions in this module
  take a rule and produce a C module with two principal functions: one to match
  the rule (creating a morphism) and one that takes a morphism and applies the
  rule. 

/////////////////////////////////////////////////////////////////////////// */

#ifndef INC_GEN_RULE_H
#define INC_GEN_RULE_H

#include "ast.h"
#include "error.h"
#include "genLabel.h"
#include "globals.h"
#include "label.h"
#include "rule.h"
#include "searchplan.h"
#include "transform.h"

FILE *rule_header;
FILE *rule_source;
struct Searchplan *searchplan;

/* Generates code from each rule declaration in the AST via calls to makeRule
 * and generateRuleCode. It also tests if each rule is a predicate rule and
 * updates the rule declaration AST nodes accordingly. */
void generateRules(List *declarations);

/* generateRuleCode creates a C module to match and apply the rule.
 * It sets up the module environment and makes the appropriate calls to
 * emitMatchingCode and emitApplicationCode depending on the structure
 * of the rule.  */
void generateRuleCode(Rule *rule, bool predicate);
 
/* Generates the searchplan from the LHS which is used to emit the matching
 * code. The generated matching code is structure as follows:
 * For a searchplan op_1,...,op_n and corresponding generated C functions
 * f_1,...,f_n, the main matching function match_R calls f_1. If f_i fails to
 * find a match, it returns false, causing match_R to return NULL. If f_i
 * finds a match, it updates the appropriate data structures (including the
 * morphism) and calls f_i+1.
 * The subsequent matching functions operate in the same way, apart from the
 * last function f_n. If f_n finds a match it returns true, signalling match_R 
 * to return the morphism.
 * This function is also responsible for printing the source file's main
 * matching function and its global variables. 
 *
 * Argument 1: The name of the rule.
 * Argument 2: The LHS graph of the rule. Used to generate the searchplan.
 * Argument 3: The list of nodes that the rule deletes. The dangling condition
 *             is checked for candidate host graph nodes that match a deleted node. */
void generateMatchingCode(string rule_name, Graph *lhs, ItemList *deleted_nodes);

/* The four emitMatcher functions take an LHS item and emit a function that 
 * searches for a matching host item. The generated code queries the host graph
 * for the appropriate item or list of items according to the LHS item and the
 * searchplan operation from which the code is generated.
 *
 * Several checks are made by each function to check if a host item matches
 * the LHS-item in the order presented below.
 * The host item must:
 * (1) Not have been matched already (GP2 requires injective matching).
 *     A boolean array, indexed by host indices, is maintained at runtime to 
 *     facilitate this check. The arrays are named matched_nodes and 
 *     matched_edges.
 * (2) Have the same mark as the the LHS-item.
 * (3) [Nodes only] Have degree compatibility with the LHS-node. The host node's
 *     in- and outdegrees must be greater or equal to that of the LHS-node. If
 *     the LHS-node is deleted node, the degrees must be equal.
 * (4) Have label compatibility with the LHS-item. This code is generated by
 *     one of the "generateListMatchingCode" functions in the genLabel module.
 *
 * If a valid host item is found, the generated code pushes its index to the
 * appropriate morphism stack and calls the function for the following 
 * searchplan operation (see emitNextMatcherCall). If there are no operations 
 * left, code is generated to return true. */

/* Writes a function to match a host graph root node by iterating over the host
 * graph's root node list. */
void emitRootNodeMatcher(Node *left_node, ItemList *deleted_nodes, SearchOp *next_op);

/* Writes a function to match a host graph node by iterating over the appropriate
 * label class tables. The iterators are generated by the function 
 * generateIteratorCode in the genLabel module. */
void emitNodeMatcher(Node *left_node, ItemList *deleted_nodes, SearchOp *next_op);

/* Writes a function corresponding to the searchplan operations matching a node 
 * from an incident edge, namely the node's (i)ncoming edge, (o)utgoing edge and
 * incident (b)idirectional edge. The character representing the searchplan 
 * operation is passed as a parameter. The generated code interrogates the
 * matched host edge's source and/or target edge. */
void emitNodeFromEdgeMatcher(Node *left_node, char type, ItemList *deleted_nodes, 
                             SearchOp *next_op);

/* Writes the code to handle the result of the label matching: updating the
 * morphism and matched_nodes array if the match is successful, and removing
 * any relevant assignments from the morphism otherwise. It also generates
 * the call to the next matching function via emitNextMatcherCall. */
void generateNodeMatchResultCode(int index, SearchOp *next_op, int indent);

/* Writes a function to match a loop edge whose incident node has already
 * been matched. */
void emitEdgeMatcher(Edge *left_edge, SearchOp *next_op);

/* Writes a function to match a host graph edge by iterating over the appropriate
 * label class tables. The iterators are generated by the function 
 * generateIteratorCode in the genLabel module. */
void emitLoopEdgeMatcher(Edge *left_edge, SearchOp *next_op);

/* Writes a function to match a host graph edge from one of its incident nodes.
 * The generated code iterates over the host node's incoming/outgoing edge arrays.
 * The 'initialise' argument is used to control which matching code is written.
 * When set to false, the function header and local variable declarations are not
 * written. The 'exit' argument controls the printing of the code to return false.
 * The 'bidirectional' argument turns on the printing of filtering code which is
 * specific to bidirectional edges. These are used for bidirectional edge matching. 
 * See below. */
void emitEdgeFromSourceMatcher(Edge *left_edge, bool initialise, bool exit, 
                               bool bidirectional, SearchOp *next_op);
void emitEdgeFromTargetMatcher(Edge *left_edge, bool initialise, bool exit, 
                               bool bidirectional, SearchOp *next_op);

/* Writes a function to match a bidirectional edge. The functions call the above
 * two functions with the appropriate flags set to generate the correct code. */
void emitBiEdgeFromSourceMatcher(Edge *left_edge, SearchOp *next_op);
void emitBiEdgeFromTargetMatcher(Edge *left_edge, SearchOp *next_op);

/* Writes the code to handle the result of the label matching: updating the
 * morphism and matched_edges array if the match is successful, and removing
 * any relevant assignments from the morphism otherwise. It also generates
 * the call to the next matching function via emitNextMatcherCall. */
void generateEdgeMatchResultCode(int index, SearchOp *next_op, int indent);

/* Writes a call to a matching function according to the passed searchplan operation. */
void emitNextMatcherCall(SearchOp* next_operation, int indent);

/* The three functions below write the function apply_<rule_name> that makes the 
 * necessary changes to the host graph according to the rule and morphism. 
 *
 * generateRemoveLHSCode is called when the RHS is the empty graph. The generated
 * function uses the morphism to remove the image of the LHS from the host graph.
 *
 * generateAddRHSCode is called when the LHS is the empty graph. The generated
 * function does not take the morphism as an argument, as that is not needed to
 * add the RHS to the host graph.
 *
 * generateApplicationCode is called when both the LHS and the RHS are not the 
 * empty graph. It generates full rule application code, including the evaluation
 * of RHS labels, supported by the RHS label generation functions in the genLabel
 * module. */ 
void generateRemoveLHSCode(string rule_name);
void generateAddRHSCode(Rule *rule);
void generateApplicationCode(Rule *rule);

#endif /* INC_GEN_RULE_H */
