# Compile time object files
COBJECTS = parser.o lex.yy.o debug.o error.o ast.o pretty.o seman.o transform.o label.o graph.o rule.o stack.o searchplan.o genMatch.o genProgram.o main.o

# Runtime object files.
RULEOBJECTS = Main_r1.o Main_r2.o DeleteNode_r1.o
ROBJECTS = debug.o error.o runtime.o init_runtime.o match.o label.o graph.o rule.o stack.o $(RULEOBJECTS)

RULEHEADERS = Main_r1.h Main_r2.h DeleteNode_r1.h

OBJECTS = $(COBJECTS) $(ROBJECTS) 

CC = gcc
CFLAGS = -g -Wall -Wextra `pkg-config --cflags --libs glib-2.0`
#CFLAGS = -g -Wall -Wextra -I/local/d0p6/chrisbak/root/include/glib-2.0 -I/local/d0p6/chrisbak/root/lib/glib-2.0/include
LFLAGS = -lglib-2.0
VALGRIND = G_SLICE=always-malloc G_DEBUG=gc-friendly valgrind --tool=memcheck --leak-check=full --leak-resolution=high --track-origins=yes

# Builds the parser and code generator, runs it on the passed GP2 program/host graph files,
# and executes the generated code.
# Usage: make all F1=<path_to_program_file> F2=<path_to_host_graph_file>
all:	
		make compile && ./GP2-compile $(F1) $(F2) && make runtime && ./GP2-run

debug:		
		make compile-debug $(F1) $(F2) && make runtime-debug

# Builds the parser and the code generator.
compile:	$(COBJECTS)
		$(CC) $(COBJECTS) $(LFLAGS) -o GP2-compile

# Builds the parser and the code generator. Runs the executable with a call to valgrind.
compile-debug:	$(COBJECTS)
		$(CC) $(COBJECTS) $(LFLAGS) -o GP2-compile 	
		$(VALGRIND) --suppressions=GNOME.supp/glib.supp ./GP2-compile $(F1) $(F2)

# Builds the executable GP2 program from code generated by compile/compile-debug.
runtime:	$(ROBJECTS)
		$(CC) $(ROBJECTS) $(LFLAGS) -o GP2-run 	

# Builds the executable GP2 program from code generated by compile/compile-debug.
# Runs the executable with a call to valgrind.
runtime-debug:	$(ROBJECTS)
		$(CC) $(ROBJECTS) $(LFLAGS) -o GP2-run 	
		$(VALGRIND) --suppressions=GNOME.supp/glib.supp ./GP2-run

clean:
		rm *.o *.output parser.c parser.h lex.yy.c GP2-run GP2-compile

# Compiler objects
main.o:		main.c error.h globals.h genProgram.h parser.h seman.h
		$(CC) $(CFLAGS) -c main.c

parser.o:	parser.c parser.h lex.yy.c
		$(CC) $(CFLAGS) -c parser.c

parser.c parser.h: gpparser.y ast.h error.h
		bison -tv gpparser.y

lex.yy.o: 	lex.yy.c 
		$(CC) $(CFLAGS) -c lex.yy.c

lex.yy.c:	gplexer.lex parser.h ast.h error.h
		flex gplexer.lex

debug.o:	debug.c error.h globals.h 
		$(CC) $(CFLAGS) -c debug.c

ast.o: 		ast.c ast.h error.h globals.h
		$(CC) $(CFLAGS) -c ast.c

pretty.o:       pretty.c pretty.h ast.h error.h globals.h seman.h
		$(CC) $(CFLAGS) -c pretty.c

seman.o:	seman.c seman.h ast.h error.h globals.h
		$(CC) $(CFLAGS) -c seman.c

label.o:	label.c label.h error.h globals.h
		$(CC) $(CFLAGS) -c label.c

graph.o:	graph.c error.h globals.h label.h stack.h graph.h 
		$(CC) $(CFLAGS) -c graph.c

rule.o:		rule.c error.h globals.h graph.h rule.h
		$(CC) $(CFLAGS) -c rule.c

transform.o:	transform.c ast.h error.h globals.h graph.h rule.h transform.h 
		$(CC) $(CFLAGS) -c transform.c

stack.o:	stack.c error.h globals.h stack.h
		$(CC) $(CFLAGS) -c stack.c

searchplan.o:	searchplan.c graph.h globals.h searchplan.h
		$(CC) $(CFLAGS) -c searchplan.c

genMatch.o:	genMatch.c error.h globals.h rule.h searchplan.h genMatch.h
		$(CC) $(CFLAGS) -c genMatch.c

genProgram.o:	genProgram.c ast.h error.h genMatch.h globals.h transform.h genProgram.h
		$(CC) $(CFLAGS) -c genProgram.c


# Runtime objects
runtime.o:	runtime.c error.h debug.h graph.h init_runtime.h $(RULEHEADERS) stack.h runtime.h
		$(CC) $(CFLAGS) -c runtime.c

match.o:	match.c globals.h graph.h label.h match.h 
		$(CC) $(CFLAGS) -c match.c

init_runtime.o:	init_runtime.c graph.h macros.h rule.h init_runtime.h 
		$(CC) $(CFLAGS) -c init_runtime.c
		
Main_r1.o:	Main_r1.c Main_r1.h graph.h macros.h match.h stack.h
		$(CC) $(CFLAGS) -c Main_r1.c 

Main_r2.o:	Main_r2.c Main_r2.h graph.h macros.h match.h stack.h
		$(CC) $(CFLAGS) -c Main_r2.c 

DeleteNode_r1.o:	DeleteNode_r1.c DeleteNode_r1.h graph.h macros.h match.h stack.h
		 	$(CC) $(CFLAGS) -c DeleteNode_r1.c 
